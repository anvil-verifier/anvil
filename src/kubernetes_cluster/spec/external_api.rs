// Copyright 2022 VMware, Inc.
// SPDX-License-Identifier: MIT
#![allow(unused_imports)]
use crate::external_api::spec::*;
use crate::kubernetes_api_objects::resource::ResourceView;
use crate::kubernetes_cluster::spec::{cluster::Cluster, message::*};
use crate::reconciler::spec::reconciler::Reconciler;
use crate::state_machine::action::*;
use crate::state_machine::state_machine::*;
use crate::temporal_logic::defs::*;
use vstd::{multiset::*, prelude::*};

verus! {

// ExternalComm is used to represent communication between the external api and controller.
// It has two variants: Input is computed by controller and sent to and consumed by external api; Output is generated by
// external api after handling the input.
// Each variant also carries a nat which represents the rest_id of the state when the input is generated or the call id of
// the corresponding input when the output is created.
// With call id, we are able to check whether the output matches the input when conducting continue_reconcile.
#[is_variant]
pub enum ExternalComm<Input, Output> {
    Input(Input, nat),
    Output(Output, nat),
}

// ExternalAPIState basically adds a set to hold communication between controller and external api to the original external api state.
pub struct ExternalAPIState<T: ExternalAPI> {
    // external_api_state is the state of the external api.
    pub external_api_state: T::State,
    // in_flight is similar to the in_flight field of the network state.
    // We use a set to accommodate the input and output of the external api which haven't been processed.
    pub in_flight: Set<ExternalComm<T::Input, T::Output>>,
}

impl<K: ResourceView, E: ExternalAPI, R: Reconciler<K, E>> Cluster<K, E, R> {

pub open spec fn external_output_matches_input(output: ExternalComm<E::Input, E::Output>, input: ExternalComm<E::Input, E::Output>) -> bool {
    &&& output.is_Output()
    &&& input.is_Input()
    &&& output.get_Output_1() == input.get_Input_1()
}

pub open spec fn external_api_state_init(s: ExternalAPIState<E>) -> bool {
    &&& s.external_api_state == E::init_state()
    &&& s.in_flight == Set::<ExternalComm<E::Input, E::Output>>::empty()
}

pub open spec fn external_api_send_output_and_receive_input(
    output: Option<ExternalComm<E::Input, E::Output>>, input: Option<ExternalComm<E::Input, E::Output>>, s: ExternalAPIState<E>
) -> ExternalAPIState<E> {
    let in_flight_remove_output = if output.is_Some() { s.in_flight.remove(output.get_Some_0()) } else { s.in_flight };
    let in_flight_prime = if input.is_Some() { in_flight_remove_output.insert(input.get_Some_0()) } else { in_flight_remove_output };
    ExternalAPIState {
        in_flight: in_flight_prime,
        ..s
    }
}

}

}
